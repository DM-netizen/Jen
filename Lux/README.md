# Description


# Emscripten

[Emscripten](https://emscripten.org/) embeds compiled C or C++ code into the browser using WebAssembly, which as a general rule is not human-readable. A program compiled into WebAssembly cannot access the web or the user's disk, but has a virtual filesystem. Preloaded scene files and images can be stored in the generated file lux.js 

Via Emscripten, C++ and JavaScript can have access to the same memory space. This allows the ImagePortCanvas to be rendered in 1-2 milliseconds once the image is rendered.

## API
In order to display an image or load an external file, the C++ program must communicate with JavaScript. Lux operates as a virtual server within the browser using a request-response protocol. All communication within the Joyographic app is initiated by the UI module, and information such as JSON and images are returned by Lux to the UI. API functions are defined in [lux_web.cpp](https://github.com/joyhughes/Jen/blob/main/Lux/src/lux_web.cpp) and are listed at the bottom of the file.

# React App

## Components of Lux C++

### Function objects and harnesses 
A function object (called a functor) contains a function that can be applied to one of a variety of data types. A harness includes a value and a list of function objects which can be calculated as needed, and are used as data fields in various types of objects. 

### Effect
Effect modify the contents of and image. They can include warps, color changes, cellular automata, or rendering an element or cluster. They are represented by function objects and stored within the scene. Effects are run sequentially within effect lists.

### Element
An element consists of any image type mapped to the range -1.0 to 1.0 in x and y and optionally a mask of the same size and type as the image. It has a position, size, and orientation within the scene that can be controlled via harnesses by functions via harnesses including user interface tools. 

### Cluster
A cluster is a grouping of elements. A function object called next_element determines the position, orientation, scale, and color of each element. Some arrangements for clusters include circles, grids, random arrangements, and along the flow lines of a vector field. Clusters can branch, and the branches can branch, producing L-systems that can resemble natural phenomena. The aurora simulation pictured above is produced by an L-system with three levels. A cluster description is stored as part of a scene file.

### Scene
A scene contains a complete description of how each image or animation frame is generated, including each element, cluster, function objects, effects, and image buffers within each of which might be used multiple times within the scene. Scenes are loaded from JSON scene files, which can be written by hand or generated by Lux.

## Images

### Implementation
An image is defined as an evenly spaced grid of values of given x and y dimensions. Double buffering is used for some effects - images are stored in buffer pair objects that include the back buffer if needed. Front and back buffers can be swapped after calculations are made. Image code includes functions for each image type including reading and writing from disc, simple imaging operations, sampling, masking, and "splatting" an element onto an image.

### FRGB pixel format
FRGB is a floating point color model. The range between 0.0 and 1.0 corresponds to the range between zero and 255 for each 8-bit color component. Colors can be oversaturated (above 1.0) or negative, expanding the range of possibilites in HDR, masking, and compositing. FRGB does not have an alpha channel - full FRGB masking is used instead. FRGB colors must be converted to standard 24-bit color in order to be displayed.

### UImage 
A UImage is a grid of 32-bit pixels represented in ARGB byte order. It is used for real time calculations and display on the web.

### FImage
FImage is a grid of FRGB values, representing an image in the FRGB color space. It also includes a bounding box in 2D floating point space that defines a coordinate for each pixel. Color values can be negative or greater thatn 1.0.  Calculations are generally slower but more accurate than UImage.

### Vector Field
VField is a grid of integer or floating point vectors representing a vector field, and a bounding box in 2D floating point Cartesian space. The VField code has a look up function that returns an interpolated vector based on the coordinate provided, and can move ("advect") a coordinate based on this result. There are a number of mathematical functions that can modify a single vector field or combine two fields together. There are also functions that can generate a vector field based on various mathematical formulae.

# Building Lux

##Command line
```
mkdir build
cd build
cmake ..
make
./lux < include arguments here >
make clean
```
##React + Emscripten
```
make
cd lux_react
npm start
^C to exit
```
See the [lux_react README](https://github.com/joyhughes/Jen/blob/main/Lux/lux_react/README.md) for instructions for installing create-react-app (which is scheduled to be replaced by Vite)

# Contributor Guide

There are two main ways to contribute to Lux - helping build the user interface or adding 



## Contributing to the user interface (JavaScript)

### UI philosophy

A sense of play
Simple user choices
Control panel as a generic container
Continuous interaction
Keeping image port uncovered

## Contributing a function, effect, or cellular automaton rule (C++)

## Contributing a scene (JSON)

## Contributing scenes

# Roadmap
