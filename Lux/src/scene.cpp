#include "scene.hpp"
#include "next_element.hpp"
#include "fimage.hpp"
#include "uimage.hpp"
#include "vector_field.hpp"
#include "warp_field.hpp"
#include "offset_field.hpp"
#include "scene_io.hpp"
#include <optional>
#include <sstream>

#define SCENE_DEBUG

// splats any element onto a particular image
template< class T > void splat_element( std::shared_ptr< buffer_pair< T > > target_buf, element& el, element_context& context ) {
    //std::cout << " splat_element" << std::endl; 
    typedef std::shared_ptr< image< T > > image_ptr;  
    typedef std::shared_ptr< buffer_pair< T > > buf_ptr;  


    any_buffer_pair_ptr img_buf_any;
    if( context.s.buffers.contains( el.img ) ) img_buf_any = context.s.buffers[ el.img ];
    if( std::holds_alternative< buf_ptr >( img_buf_any ) ) { // Check if element image is same type as target. Future - splat image of different type.
        buf_ptr img_buf  = std::get< buf_ptr >( img_buf_any ); 
        if( img_buf->has_image() ) {
            image< T >& img = img_buf->get_image();
            std::optional< std::reference_wrapper< image< T > > > mask = std::nullopt;
            std::optional< T > tint = std::nullopt;

            any_buffer_pair_ptr mask_buf_any;
            if( context.s.buffers.contains( el.mask ) ) mask_buf_any = context.s.buffers[ el.mask ];

            // Future - splat mask of different type.
            if( std::holds_alternative< buf_ptr >( mask_buf_any ) ) mask = std::get< buf_ptr >( mask_buf_any )->get_image();
            if( el.tint.has_value() ) if( std::holds_alternative< T >( *(el.tint) ) ) tint = std::get< T >( *(el.tint) );
            float th = el.rotation;
            if( el.orientation_lock ) th += el.orientation;
            //std::cout << " prepared to splat\n";
            image_ptr target( &(target_buf->get_image()) );
            if( target.get() ) target->splat( el.position, el.scale, th, img, mask, tint, el.mmode ); 
            else std::cout << "error - no target image\n";
            //std::cout << "splat complete\n";
        }
    }
}

// splats any element onto any image
void element::render( any_buffer_pair_ptr& target, element_context& context ) { 
    //std::cout << " element::render\n";
    pixel_type ptype = ( pixel_type )target.index();
    //std::cout << " pixel type " << ptype << std::endl;
    switch( ( pixel_type )target.index() ) {
        case( PIXEL_FRGB   ): splat_element< frgb   >( std::get< std::shared_ptr< buffer_pair< frgb > > >( target ), *this, context ); break;
        case( PIXEL_UCOLOR ): splat_element< ucolor >( std::get< std::shared_ptr< buffer_pair< ucolor > > >( target ), *this, context ); break;
        case( PIXEL_VEC2F  ): splat_element< vec2f  >( std::get< std::shared_ptr< buffer_pair< vec2f > > >( target ), *this, context ); break;
        case( PIXEL_INT    ): splat_element< int    >( std::get< std::shared_ptr< buffer_pair< int > > >( target ), *this, context ); break;
        case( PIXEL_VEC2I  ): splat_element< vec2i  >( std::get< std::shared_ptr< buffer_pair< vec2i > > >( target ), *this, context ); break;
    }
}

void element::operator () ( any_buffer_pair_ptr& buf, element_context& context ) {
    render( buf, context );
}

// Recursively generate and render elements
void cluster::render( scene& s, any_buffer_pair_ptr& buf ) { 
    // The lambda function uses a generic lambda with auto as the argument type, and returns the same type as its argument. 
    // The std::visit function will invoke this lambda function with the correct argument based on the type stored in the variant, 
    // and will return the value returned by the lambda function. Note that the decltype(ptr) return type is used to preserve the 
    // exact type of the stored object. (Generated by ChatGPT)
    element el = root_elem;
    element_context context( el, *this, s, buf );
    //std::cout << " context created" << std::endl;
    // If next_element contains no functions, simply render initial element
    if( next_elem.functions.size() == 0 ) el.render( buf, context );
    else while( next_elem( context ) ) {
        el.render( buf, context ); 
        //std::cout << "rendered element " << el.index << std::endl; 
    }
    //( ( fimage & )img ).write_jpg( "hk_cluster.jpg", 100 ); // debug - save frame after each cluster                   
}

void cluster::operator () ( any_buffer_pair_ptr& buf, element_context& context ) {
    render( context.s, context.buf ); // does not require buffer swap
    // add logic for double buffering if background dependent and top level true
}

// change root element parameters for branching cluster
void cluster::set_root( element& el ) {
    root_elem.position = el.position;
    root_elem.scale = el.scale;
    root_elem.rotation = el.rotation;
    root_elem.orientation = el.orientation;
    root_elem.orientation_lock = el.orientation_lock;
    root_elem.derivative = el.derivative;
    root_elem.derivative_lock = el.derivative_lock;
    root_elem.index = 0;
}

/*
// render into a buffer pair. Rendering modifies image directly - does not require buffer swap.
// in this case the cluster serves as an effect functor (the effect being rendering)
void cluster::operator () ( any_buffer_pair buf, const float& t ) {
    render( buf.get_image(), t );
}
*/

void effect_list::resize( const vec2i& new_dim ) {
    // need to resize buffer instead?
    dim = new_dim;
    switch( ptype ) {
        case( PIXEL_FRGB   ): buf = std::make_shared< buffer_pair< frgb >   >( dim ); break;
        case( PIXEL_UCOLOR ): buf = std::make_shared< buffer_pair< ucolor > >( dim ); break;
        case( PIXEL_VEC2F  ): buf = std::make_shared< buffer_pair< vec2f >  >( dim ); break;
        case( PIXEL_INT    ): buf = std::make_shared< buffer_pair< int >    >( dim ); break;
        default: break;
    }
}

void effect_list::render( scene& s ) {
    std::cout << "effect_list::render()" << std::endl;
    if( rmode == MODE_EPHEMERAL || !rendered ) { // ephemeral buffers are re-rendered each frame
        if( s.buffers.contains( source_name ) ) {  // load source image or result into buffer
            any_buffer_pair_ptr b = s.buffers[ source_name ];
            switch( ptype ) {
                case( PIXEL_FRGB   ): std::get< std::shared_ptr< buffer_pair< frgb   > > >( buf )->set( std::get< std::shared_ptr< buffer_pair< frgb   > > >( b )->get_image() ); break;
                case( PIXEL_UCOLOR ): std::get< std::shared_ptr< buffer_pair< ucolor > > >( buf )->set( std::get< std::shared_ptr< buffer_pair< ucolor > > >( b )->get_image() ); break;
                case( PIXEL_VEC2F  ): std::get< std::shared_ptr< buffer_pair< vec2f  > > >( buf )->set( std::get< std::shared_ptr< buffer_pair< vec2f  > > >( b )->get_image() ); break;
                case( PIXEL_INT    ): std::get< std::shared_ptr< buffer_pair< int    > > >( buf )->set( std::get< std::shared_ptr< buffer_pair< int    > > >( b )->get_image() ); break;
                case( PIXEL_VEC2I  ): std::get< std::shared_ptr< buffer_pair< vec2i  > > >( buf )->set( std::get< std::shared_ptr< buffer_pair< vec2i  > > >( b )->get_image() ); break;
            }
        }
        else {  // blank buffer
            std::visit( [&]( auto& buf_ptr ) { buf_ptr->set( dim ); }, buf );       
        }
    }
    if( !( rmode == MODE_STATIC && rendered ) ) { // no need to re-render static buffers
        for( auto& name : effects ) {
            // default element and cluster
            element default_element;
            next_element default_next_element;
            cluster default_cluster( default_element, default_next_element );
            element_context context( default_element, default_cluster, s, buf );
            s.effects[ name ]( buf, context );
            //std::cout << "rendered effect " << name << std::endl
        }
        rendered = true;
    }
}


scene::scene( float time_interval_init ) : time_interval( time_interval_init ), default_time_interval( time_interval_init ) {}

scene::scene( const std::string& filename, float time_interval_init ) 
    : time( 0.0f ), time_interval( time_interval_init ), default_time_interval( time_interval_init )
{
    scene_reader reader( *this, filename );
}

void scene::render() {
    std::cout << "scene::render()" << std::endl; 
    for( auto& eff_list : queue ) eff_list.render( *this );
    time += time_interval;
}

void scene::render_and_save( 
    const std::string& filename, 
    const vec2i& dim,
    pixel_type ptype, 
    file_type ftype, 
    int quality )
{ 
    std::cout << "scene::render_and_save()" << std::endl;
    any_buffer_pair_ptr any_out;
    // bounds set automatically by image constructor
    switch( ptype ) {
        case( PIXEL_FRGB   ): any_out = std::make_shared< buffer_pair< frgb >   >( dim ); break;
        case( PIXEL_UCOLOR ): any_out = std::make_shared< buffer_pair< ucolor > >( dim ); break;
        case( PIXEL_VEC2F  ): any_out = std::make_shared< buffer_pair< vec2f >  >( dim ); break;
        case( PIXEL_INT    ): any_out = std::make_shared< buffer_pair< int >    >( dim ); break;
        case( PIXEL_VEC2I  ): any_out = std::make_shared< buffer_pair< vec2i >  >( dim ); break;
    }
    //std::cout << "Created image pointer" << std::endl;
    // future: add pre-effects here
    set_output_buffer( any_out ); // set output buffer
    render(); // render into image

    auto out = std::get< ubuf_ptr >( any_out );
    if( out->has_image() ) {
        std::cout << "writing image" << std::endl;
        ((uimage *)(out->get_image_ptr().get()))->write_jpg( filename, quality );
    }
    else {
        std::cout << "no image to write" << std::endl;
    }
    //std::visit( [ & ]( auto& out ){ out->get_image().write_file( filename, ftype, quality ); }, any_out );
} 

void scene::animate( std::string basename, int nframes, vec2i dim )
{
    //std::cout << "scene::animate" << std::endl;
    time_interval = 1.0f / nframes;
    time = 0.0f;
    for( int frame = 0; frame < nframes; frame++ ) {
        std::ostringstream s;
        s << basename << std::setfill('0') << std::setw(4) << frame << ".jpg";
        std::string filename = s.str();
        render_and_save( filename, dim );
        time += time_interval;
        std::cout << "frame " << frame << std::endl;
    }

    // future: make the video file here 
}

void scene::set_output_buffer( any_buffer_pair_ptr& buf ) {
    std::cout << "scene::set_output_buffer()" << std::endl;
    auto& output_list = queue[ queue.size() - 1 ];
    output_list.buf = buf;
    output_list.ptype = ( pixel_type )buf.index();
    vec2i dim_out;
    std::visit( [&]( auto& b ) { dim_out = b->get_image().get_dim(); }, buf );
    for( int i = 0; i < queue.size() - 1; i++ ) {
        auto& eff_list = queue[ i ];
        eff_list.rendered = false;
        vec2i dim = { std::round( dim_out.x * eff_list.relative_dim ), std::round( dim_out.y * eff_list.relative_dim ) };
        eff_list.resize( dim );
    }
}

effect_list& scene::get_effect_list( const std::string& name ) {
    for( auto& eff_list : queue )
        if( eff_list.name == name )
            return eff_list;
    throw std::runtime_error( "effect list not found" );
}